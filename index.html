<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - loader - ttf</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>
<div id="info"></div>
<script src="scoreoutputer.min.js"></script>
<script>
    // 建構子 ScoreOutputer 接受一個字串，該字串為 csv 的檔案名稱
    // 以下面範例，檔名就為 "109598105(總分: 6).csv"
    var so = new ScoreOutputer("110598045");
    so.installCSS(function () {
        // 安裝 bootstrap 的 css，如果在 html 上方引用 bootstrap 5.1.1 的話就不用使用 installCSS ，注意一定要 bootstrap css 5.1.1 版
        // installCSS 接收一個 callback 當作參數，作為成功安裝 bootstrap css 的回呼函式

        //加入項目，分數，完成狀況
        //第一個參數為 項目名稱
        //第2個參數為 項目分數
        //第3個參數為 完成狀況，有完成 true/未完成 false
        //有幾個項目就呼叫幾個 addChild
        //addChild 要比 renderModal 先呼叫
        so.addChild("創建場景", 2, true);
        so.addChild("讀取字形檔", 2, true);
        so.addChild("將地支以圓圈排列", 2, true);
        so.addChild("滑鼠點擊 12 地支分別跳轉網頁", 1, true);
        so.addChild("顯示高等計算機圖形作業", 1, true);
        so.addChild("時鐘效果", 1, true);
        so.addChild("任何 ply 格式模型", 1, false);

        //產生自評表，參數如下所示
        so.renderModal(
            //1. 自評表插入位置 (預設 document.body)
            document.body,
            //2. 自評表背景 (預設紅色)
            'rgba(100,45,58,1)',
            //3. 自評表文字顏色 (預設白色)
            'white',
            //4. 自評表文字大小 (預設 14pt)
            '15pt',
            //5. 自評表 checkbox 文字大小 (預設多少忘了)
            '15px',
            //6. 自評表標題 (預設 "自我評分表")
            dialogTitle = '自我評分表 (助教測試用)'
        );

        //設定下載按鈕 <-- 一定要呼叫這個函數，不然沒有下載功能
        so.installDownloadBtn();

        //產生 "開啟自評表按鈕"
        so.renderBtn(
            //自評表按鈕插入位置
            document.querySelector("#info"),
            //自評表按鈕文字
            "開啟自評表"
        );
    });
</script>
<script src="./opentype.min.js"></script>
<script src="./three.min.js"></script>
<script src="./TTFLoader.js"></script>
<script>
    let container;
    let camera, cameraTarget, scene, renderer;
    let targetRotation = 0;
    let windowHalfX = window.innerWidth / 2;
    let clockGroup, clockTextGroup;
    let mouse = new THREE.Vector2();
    let raycaster = new THREE.Raycaster();
    let clockCircleMeshes = [];

    init();
    animate();

    function init() {
        container = document.createElement('div');
        document.body.appendChild(container);

        // camera
        camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 1500);
        camera.position.set(0, 700, 1100);
        cameraTarget = new THREE.Vector3(0, 150, 0);

        // scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        // lights
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.125);
        dirLight.position.set(0, 0, 1).normalize();
        scene.add(dirLight);

        const pointLight = new THREE.PointLight(0xffffff, 1.5);
        pointLight.position.set(0, 300, 90);
        scene.add(pointLight);

        // plane
        let plane = createPlaneMesh()
        scene.add(plane);

        // clock group
        let clockPositionY = 300;
        clockGroup = new THREE.Group();
        clockGroup.position.y = clockPositionY;

        clockTextGroup = new THREE.Group();
        clockTextGroup.position.y = clockPositionY;

        // clock
        let clockMesh = createClockMesh();
        clockGroup.add(clockMesh);

        // ground text and clock text
        let loader = new THREE.TTFLoader();
        loader.load('./ttf/edukai-4.0.ttf', function (json) {
            let font = new THREE.Font(json);

            // ground text mesh
            let groundText = "高等計算機圖學作業"
            let groundTextMesh = createGroundTextMesh(groundText, font);
            scene.add(groundTextMesh);

            // clock text mesh
            createClockTextGroup(font);
        });

        scene.add(clockGroup);
        scene.add(clockTextGroup);

        // clock animation
        createClockAnimation();

        // renderer
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        // events
        container.style.touchAction = 'none';

        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('resize', onWindowResize);
    }

    function onMouseDown(event) {
        event.preventDefault();
        mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        let intersects = raycaster.intersectObjects(clockCircleMeshes);

        if (intersects.length > 0) {
            window.open(intersects[0].object.userData.url);
        }
    }

    function onWindowResize() {
        windowHalfX = window.innerWidth / 2;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function createPlaneMesh() {
        let plane = new THREE.Mesh(
            new THREE.PlaneGeometry(1000, 1000),
            new THREE.MeshBasicMaterial({color: 0xffffff, opacity: 0.5, transparent: true})
        );
        plane.position.y = 100;
        plane.rotation.x = -Math.PI / 2;
        return plane;
    }

    function createClockMesh() {
        return new THREE.Mesh(
            new THREE.CircleGeometry(100, 100),
            new THREE.MeshBasicMaterial({color: 0x66ccff, opacity: 0.5, transparent: true})
        );
    }

    function createClockTextGroup(font) {
        let clockTexts = ["子", "丑", "寅", "卯", "辰", "巳", "午", "未", "申", "酉", "戌", "亥"];
        let hwNumber = ["12", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11"];
        let positionOffsets = getCircleTextMeshPositionOffsets();
        clockTexts.forEach(function (clockText, index) {
            let offset = positionOffsets[index];
            let clockCircleMesh = createClockCircleMesh();
            clockCircleMesh.position.x = offset.x;
            clockCircleMesh.position.y = offset.y;
            clockCircleMesh.userData = {
                url: `https://ntut-cg-lab.github.io/cg2021f-hw${hwNumber[index]}-conflick0/`
            }
            clockCircleMeshes.push(clockCircleMesh);
            clockTextGroup.add(clockCircleMesh);

            let clockTextMesh = createClockTextMesh(clockText, font);
            clockTextMesh.position.x += offset.x;
            clockTextMesh.position.y += offset.y;
            clockTextGroup.add(clockTextMesh);
        });
    }

    function createClockCircleMesh() {
        return new THREE.Mesh(
            new THREE.CircleGeometry(13, 100),
            new THREE.MeshBasicMaterial({color: 0x3366ff, opacity: 0.5, transparent: true})
        );
    }

    function createGroundTextMesh(text, font) {
        const size = 70,
            height = 5,
            hover = 100,
            curveSegments = 4,
            bevelThickness = 2,
            bevelSize = 1.5;

        let textGeo = new THREE.TextGeometry(text, {
            font: font,
            size: size,
            height: height,
            curveSegments: curveSegments,
            bevelThickness: bevelThickness,
            bevelSize: bevelSize,
            bevelEnabled: true

        });

        textGeo.computeBoundingBox();
        textGeo.computeVertexNormals();

        const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
        let material = new THREE.MeshPhongMaterial({color: 0xffffff, flatShading: true});
        let textMesh = new THREE.Mesh(textGeo, material);
        textMesh.position.x = centerOffset;
        textMesh.position.y = hover;
        textMesh.position.z = 0;

        textMesh.rotation.x = -Math.PI / 2;
        textMesh.rotation.y = Math.PI * 2;

        return textMesh;
    }

    function createClockTextMesh(text, font) {
        const size = 15,
            height = 5,
            curveSegments = 4,
            bevelThickness = 1,
            bevelSize = 0.5;

        let textGeo = new THREE.TextGeometry(text, {
            font: font,
            size: size,
            height: height,
            curveSegments: curveSegments,
            bevelThickness: bevelThickness,
            bevelSize: bevelSize,
            bevelEnabled: true
        });

        textGeo.computeBoundingBox();
        textGeo.computeVertexNormals();

        const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
        let material = new THREE.MeshPhongMaterial({color: 0xffffff, flatShading: true});
        let textMesh = new THREE.Mesh(textGeo, material);

        textMesh.position.x = centerOffset - 2;
        textMesh.position.y = -5;
        textMesh.rotation.y = Math.PI * 2;

        return textMesh;
    }

    function getCircleTextMeshPositionOffsets() {
        let h = 75; // triangle hypotenuse (circle text meshes radius)
        let s = h * 0.5 // triangle short side
        let l = Math.round(h * 0.9) // triangle long side

        return [
            {x: 0, y: h},
            {x: s, y: l},
            {x: l, y: s},
            {x: h, y: 0},
            {x: l, y: -s},
            {x: s, y: -l},
            {x: 0, y: -h},
            {x: -s, y: -l},
            {x: -l, y: -s},
            {x: -h, y: 0},
            {x: -l, y: s},
            {x: -s, y: l},
        ]
    }

    function createClockAnimation() {
        const secondHandLine = createSecondHandLine()
        clockGroup.add(secondHandLine);
        const minuteHandLine = createMinuteHandLine()
        clockGroup.add(minuteHandLine);
        const hourHandLine = createHourHandLine()
        clockGroup.add(hourHandLine);

        setInterval(function () {
            let date = new Date();
            let hours = date.getHours();
            let minutes = date.getMinutes();
            let seconds = date.getSeconds();
            let milliseconds = date.getMilliseconds();
            let smoothSeconds = seconds + ( milliseconds / 1000 );
            minutes = minutes + ( smoothSeconds / 60 );

            hourHandLine.rotation.z = -THREE.Math.degToRad( 0.5 * ( (60 * hours) + minutes ) );
            minuteHandLine.rotation.z = -THREE.Math.degToRad( 6 * minutes );
            secondHandLine.rotation.z = -THREE.Math.degToRad( 6 * smoothSeconds );
        }, 1000);
    }

    function createSecondHandLine() {
        const material = new THREE.LineBasicMaterial({
            color: 0xffffff
        });

        const points = [
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 85, 20)
        ];

        return createLine(points, material);
    }

    function createMinuteHandLine() {
        const material = new THREE.LineBasicMaterial({
            color: 0xffffff
        });

        const points = [
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 75, 20)
        ];

        return createLine(points, material);
    }

    function createHourHandLine() {
        const material = new THREE.LineBasicMaterial({
            color: 0xffffff
        });

        const points = [
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 50, 20)
        ];

        return createLine(points, material);
    }

    function createLine(points, material) {
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        return new THREE.Line(geometry, material);
    }

    function animate() {
        requestAnimationFrame(animate);
        camera.lookAt(cameraTarget);
        renderer.render(scene, camera);
    }

</script>
</body>
</html>
