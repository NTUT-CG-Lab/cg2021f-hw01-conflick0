<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - loader - ttf</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>
<div id="btnContainer"></div>
<script src="scoreoutputer.min.js"></script>
<script>
    // 建構子 ScoreOutputer 接受一個字串，該字串為 csv 的檔案名稱
    // 以下面範例，檔名就為 "109598105(總分: 6).csv"
    var so = new ScoreOutputer("110598045");
    so.installCSS(function(){
        // 安裝 bootstrap 的 css，如果在 html 上方引用 bootstrap 5.1.1 的話就不用使用 installCSS ，注意一定要 bootstrap css 5.1.1 版
        // installCSS 接收一個 callback 當作參數，作為成功安裝 bootstrap css 的回呼函式

        //加入項目，分數，完成狀況
        //第一個參數為 項目名稱
        //第2個參數為 項目分數
        //第3個參數為 完成狀況，有完成 true/未完成 false
        //有幾個項目就呼叫幾個 addChild
        //addChild 要比 renderModal 先呼叫
        so.addChild("創建場景", 2, true);
        so.addChild("讀取字形檔", 2, true);
        so.addChild("將地支以圓圈排列", 2, true);
        so.addChild("滑鼠點擊 12 地支分別跳轉網頁", 1, false);
        so.addChild("高等計算機圖形作業", 1, true);
        so.addChild("時鐘效果", 1, false);
        so.addChild("任何 ply 格式模型", 1, false);

        //產生自評表，參數如下所示
        so.renderModal(
            //1. 自評表插入位置 (預設 document.body)
            document.querySelector("#btnContainer"),
            //2. 自評表背景 (預設紅色)
            'rgba(100,45,58,1)',
            //3. 自評表文字顏色 (預設白色)
            'white',
            //4. 自評表文字大小 (預設 14pt)
            '15pt',
            //5. 自評表 checkbox 文字大小 (預設多少忘了)
            '15px',
            //6. 自評表標題 (預設 "自我評分表")
            dialogTitle='自我評分表 (助教測試用)'
        );

        //設定下載按鈕 <-- 一定要呼叫這個函數，不然沒有下載功能
        so.installDownloadBtn();

        //產生 "開啟自評表按鈕"
        so.renderBtn(
            //自評表按鈕插入位置
            document.body,
            //自評表按鈕文字
            "開啟自評表"
        );
    });
</script>
<script src="./opentype.min.js"></script>
<script src="./three.min.js"></script>
<script src="./TTFLoader.js"></script>
<script>
    let container;
    let camera, cameraTarget, scene, renderer;
    let targetRotation = 0;
    let windowHalfX = window.innerWidth / 2;

    init();
    animate();

    function init() {
        container = document.createElement('div');
        document.body.appendChild(container);

        // camera
        camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 1500);
        camera.position.set(0, 500, 1000);
        cameraTarget = new THREE.Vector3(0, 150, 0);

        // scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        // lights
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.125);
        dirLight.position.set(0, 0, 1).normalize();
        scene.add(dirLight);

        const pointLight = new THREE.PointLight(0xffffff, 1.5);
        pointLight.position.set(0, 100, 90);
        scene.add(pointLight);

        // plane
        let plane = createPlaneMesh()
        scene.add(plane);

        // circle
        let circle = createCircleMesh()
        scene.add(circle);

        // text
        let loader = new THREE.TTFLoader();
        loader.load('./ttf/edukai-4.0.ttf', function (json) {
            let font = new THREE.Font(json);

            // ground text
            let groundText = "高等計算機圖學"
            let groundTextMesh = createGroundTextMesh(groundText, font);
            scene.add(groundTextMesh)

            // circle text
            let circleTexts = ["子", "丑", "寅", "卯", "辰", "巳", "午", "未", "申", "酉", "戌", "亥"]
            let positionOffsets = getCircleTextMeshPositionOffsets()
            circleTexts.forEach(function (circleText, index){
                let circleTextMesh = createCircleTextMesh(circleText, font)
                let offset = positionOffsets[index]
                circleTextMesh.position.x += offset.x
                circleTextMesh.position.y += offset.y
                scene.add(circleTextMesh)
            })

        });

        // renderer
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        // events
        container.style.touchAction = 'none';
        window.addEventListener('resize', onWindowResize);
    }

    function onWindowResize() {
        windowHalfX = window.innerWidth / 2;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function createPlaneMesh() {
        let plane = new THREE.Mesh(
            new THREE.PlaneGeometry(1000, 1000),
            new THREE.MeshBasicMaterial({color: 0xffffff, opacity: 0.5, transparent: true})
        );
        plane.position.y = 100;
        plane.rotation.x = -Math.PI / 2;
        return plane
    }

    function createCircleMesh() {
        let circle = new THREE.Mesh(
            new THREE.CircleGeometry(100, 100),
            new THREE.MeshBasicMaterial({color: 0x66ccff, opacity: 0.5, transparent: true})
        );
        circle.position.y = 300;
        circle.rotation.x = 0;
        return circle
    }

    function createGroundTextMesh(text, font) {
        const size = 70,
            height = 5,
            hover = 100,
            curveSegments = 4,
            bevelThickness = 2,
            bevelSize = 1.5;

        let textGeo = new THREE.TextGeometry(text, {
            font: font,
            size: size,
            height: height,
            curveSegments: curveSegments,
            bevelThickness: bevelThickness,
            bevelSize: bevelSize,
            bevelEnabled: true

        });

        textGeo.computeBoundingBox();
        textGeo.computeVertexNormals();

        const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
        let material = new THREE.MeshPhongMaterial({color: 0xffffff, flatShading: true});
        let textMesh = new THREE.Mesh(textGeo, material);
        textMesh.position.x = centerOffset;
        textMesh.position.y = hover;
        textMesh.position.z = 0;

        textMesh.rotation.x = -Math.PI / 2;
        textMesh.rotation.y = Math.PI * 2;

        return textMesh
    }

    function createCircleTextMesh(text, font) {
        const size = 20,
            height = 5,
            hover = 300,
            curveSegments = 4,
            bevelThickness = 2,
            bevelSize = 1.5;

        let textGeo = new THREE.TextGeometry(text, {
            font: font,
            size: size,
            height: height,
            curveSegments: curveSegments,
            bevelThickness: bevelThickness,
            bevelSize: bevelSize,
            bevelEnabled: true
        });

        textGeo.computeBoundingBox();
        textGeo.computeVertexNormals();

        const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
        let material = new THREE.MeshPhongMaterial({color: 0xffffff, flatShading: true});
        let textMesh = new THREE.Mesh(textGeo, material);
        textMesh.position.x = centerOffset;
        textMesh.position.y = hover;
        textMesh.position.z = 0;

        textMesh.rotation.x = 0;
        textMesh.rotation.y = Math.PI * 2;

        return textMesh
    }

    function getCircleTextMeshPositionOffsets() {
        let h = 75; // triangle hypotenuse (circle text meshes radius)
        let s = h * 0.5 // triangle short side
        let l = Math.round(h * 0.9) // triangle long side

        return [
            {x: 0, y: h},
            {x: s, y: l},
            {x: l, y: s},
            {x: h, y: 0},
            {x: l, y: -s},
            {x: s, y: -l},
            {x: 0, y: -h},
            {x: -s, y: -l},
            {x: -l, y: -s},
            {x: -h, y: 0},
            {x: -l, y: s},
            {x: -s, y: l},
        ]
    }

    function animate() {
        requestAnimationFrame(animate);
        camera.lookAt(cameraTarget);
        renderer.render(scene, camera);
    }

</script>
</body>
</html>
